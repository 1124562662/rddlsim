domain inventory_control_continuous_mdp {

	types { 
		item : object;
	};
	
	pvariables {
		stock(item) : { state-fluent, real, default = 0.0 };
		budget : { non-fluent, real, default=100.0 };//per state budget
		order(item) : { action-fluent, real, default = 0.0 };
		
		//correct if demand' not a function of demand , unlike reservoir 
		payoff(item) : { non-fluent, real, default = 1.0 };
		cost(item) : { non-fluent, real, default = 0.5 };
		PERISH(item) : { non-fluent, real, default = 1.0 };
		
		DEMAND-WIDTH(item) : { non-fluent, real, default = 5.0 };
		DEMAND-CENTER(item) : { non-fluent, real, default = 10.0 };// Uniform [DEMAND-CENTER - DEMAND-WIDTH, DEMAND-CENTER + DEMAND-WIDTH]
		DEMAND-SLOPE(item) : { non-fluent, real, default = 2.0 };
		
		temperature(item) : { interm-fluent, real};//in [ DEMAND-CENTER - DEMAND-WIDTH, DEMAND-CENTER + DEMAND-WIDTH]
		demand(item) : { interm-fluent, real };// in [ DEMAND-CENTER, DEMAND-CENTER + DEMAND-SLOPE*DEMAND-WIDTH]
		
		fulfilled-demand(item) : { interm-fluent, real };
		profit : { interm-fluent, real };
		
	};
	
	cpfs {
		
		temperature(?t) = Uniform(DEMAND-CENTER(?t) - DEMAND-WIDTH(?t), DEMAND-CENTER(?t) + DEMAND-WIDTH(?t));
		demand(?t) = [ DEMAND-CENTER(?t) ] + DEMAND-SLOPE(?t) * abs[ temperature(?t) - DEMAND-CENTER(?t) ];
		
		fulfilled-demand(?t) = min[stock(?t), demand(?t)];
				
		profit = sum_{?t : item}[ ( payoff(?t) ) * fulfilled-demand(?t) ];
					
		stock'(?t) = if( stock(?t) < demand(?t) ) then order(?t) else [ PERISH(?t)*(stock(?t) - demand(?t)) + order(?t) ];
						
	};
	 
	reward = profit - sum_{?t : item}[ cost(?t)*order(?t) ];
	
	action-preconditions {
		forall_{?t : item}[ order(?t) >= 0.0 ];
		[ sum_{?t : item} order(?t) ] <= budget;// (DEMAND-CENTER(?t)) * sum_{?t:item}[1];
	};
	
	state-invariants {
		forall_{?t : item}[ stock(?t) >= 0.0 ];
		forall_{?t : item}[ temperature(?t) <= DEMAND-CENTER(?t) + DEMAND-WIDTH(?t) ];
		forall_{?t : item}[ temperature(?t) >= DEMAND-CENTER(?t) - DEMAND-WIDTH(?t) ];
		forall_{?t : item}[ demand(?t) >= DEMAND-CENTER(?t) ];
		forall_{?t : item}[ demand(?t) <= DEMAND-CENTER(?t) + DEMAND-SLOPE(?t)*DEMAND-WIDTH(?t) ];
		//[ sum_{?t : item} stock(?t) ] <= capacity;
	};
}