domain inventory_control_continuous_mdp {

	types { 
		item : object;
	};
	
	pvariables {
		stock(item) : { state-fluent, real, default = 0.0 };
		order(item) : { action-fluent, real, default = 0.0 };
		demand(item) : { state-fluent, real, default = 5.0 };
		
		payoff(item) : { non-fluent, real, default = 1.0 };
		cost(item) : { non-fluent, real, default = 0.9 };
		
		DEMAND-WIDTH : { non-fluent, real, default = 2.0 };
		DEMAND-CENTER : { non-fluent, real, default = 5.0 };// Uniform [DEMAND-CENTER - DEMAND-WIDTH, DEMAND-CENTER + DEMAND-WIDTH]
		
		fulfilled-demand(item) : { interm-fluent, real };
		capacity : { interm-fluent, real };
		budget : { interm-fluent, real };
		profit : { interm-fluent, real };
		
		year : { state-fluent, int, default = 0 };
		EPSILON : { non-fluent, real, default = 0.1 };
		BONUS : { non-fluent, real, default = 0.9};
	};
	
	cpfs {
		year' = year + 1;
		
		demand'(?t) = Uniform(DEMAND-CENTER - DEMAND-WIDTH, DEMAND-CENTER + DEMAND-WIDTH);
		fulfilled-demand(?t) = min[stock(?t), demand(?t)];
		
		capacity = sum_{?t:item}[DEMAND-CENTER + DEMAND-WIDTH];
				
		profit = sum_{?t : item}[ ( payoff(?t) ) * fulfilled-demand(?t) ];
		
		//extra funds available now as a linear fraction of fulfilled-demand
		budget = if ( year == 0 ) then sum_{?t: item}[(DEMAND-CENTER + DEMAND-WIDTH)] 
					else sum_{?t: item}[ BONUS * fulfilled-demand(?t) ] ;
					
		stock'(?t) = if( stock(?t) < demand(?t) ) then order(?t) else stock(?t)-demand(?t)+order(?t);
						
	};
	 
	reward = profit - sum_{?t : item}[ 0 - cost(?t)*order(?t) ];
	
	state-invariants {
		forall_{?t : item}[ stock(?t) >= 0 ];
		forall_{?t : item}[ order(?t) >= 0 ];
		[ sum_{?t : item} stock(?t) ] <= capacity - EPSILON;
		[ sum_{?t : item} order(?t) ] <= budget;
	};
}